#!/bin/bash
#
# Copyright (C) 2007 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# opcode-gen <file>
#
# This script uses the file bytecodes.txt (in this directory) to
# generate code inside the given <file>, based on the directives found
# in that file:
#
#     opcodes:       static final ints for each opcode
#     dops:          static final objects for each opcode
#     dops-init:     initialization code for the "dops"
#     first-opcodes: a comment indicating which opcodes are at the head
#                    position of instruction fitting chains

file="$1"
tmpfile="/tmp/$$.txt"

if [ "x$1" = "x" ]; then
    echo "must specify a file"
    exit 1
fi

# Set up prog to be the path of this script, including following symlinks,
# and set up progdir to be the fully-qualified pathname of its directory.
prog="$0"
while [ -h "${prog}" ]; do
    newProg=`/bin/ls -ld "${prog}"`
    newProg=`expr "${newProg}" : ".* -> \(.*\)$"`
    if expr "x${newProg}" : 'x/' >/dev/null; then
        prog="${newProg}"
    else
        progdir=`dirname "${prog}"`
        prog="${progdir}/${newProg}"
    fi
done
oldwd=`pwd`
progdir=`dirname "${prog}"`
cd "${progdir}"
progdir=`pwd`
prog="${progdir}"/`basename "${prog}"`
cd "${oldwd}"

bytecodeFile="$progdir/bytecode.txt"

awk -v "bytecodeFile=$bytecodeFile" '

BEGIN {
    MAX_OPCODE = 65535;
    readBytecodes();
    deriveOpcodeChains();
    consumeUntil = "";
}

consumeUntil != "" {
    if (index($0, consumeUntil) != 0) {
        consumeUntil = "";
    } else {
        next;
    }
}

/BEGIN\(opcodes\)/ {
    consumeUntil = "END(opcodes)";
    print;

    for (i = 0; i <= MAX_OPCODE; i++) {
        if (hex[i] == "") continue;
        printf("    public static final int %s = 0x%s;\n",
               uppername[i], hex[i]);
    }

    next;
}

/BEGIN\(first-opcodes\)/ {
    consumeUntil = "END(first-opcodes)";
    print;

    for (i = 0; i <= MAX_OPCODE; i++) {
        if (isFirst[i] == "true") {
            printf("    //     DalvOps.%s\n", uppername[i]);
        }
    }

    next;
}

/BEGIN\(dops\)/ {
    consumeUntil = "END(dops)";
    print;

    for (i = 0; i <= MAX_OPCODE; i++) {
        if ((hex[i] == "") || (index(name[i], "unused") != 0)) {
            continue;
        }

        nextOp = nextOpcode[i];
        nextOp = (nextOp == -1) ? "NO_NEXT" : uppername[nextOp];

        printf("    public static final Dop %s =\n" \
               "        new Dop(DalvOps.%s, DalvOps.%s,\n" \
               "            DalvOps.%s, Form%s.THE_ONE, %s,\n" \
               "            \"%s\");\n\n",
               uppername[i], uppername[i], family[i], nextOp, format[i],
               hasres[i], name[i]);
    }

    next;
}

/BEGIN\(dops-init\)/ {
    consumeUntil = "END(dops-init)";
    print;

    for (i = 0; i <= MAX_OPCODE; i++) {
        if ((hex[i] == "") || (index(name[i], "unused") != 0)) {
            continue;
        }
        if (index(name[i], "unused") != 0) {
            continue;
        }
        printf("        set(%s);\n", uppername[i]);
    }

    next;
}

{ print; }

# Read the bytecode description file.
function readBytecodes(i, parts, line, cmd, status, count) {
    # locals: parts, line, cmd, status, count
    for (;;) {
        # Read a line.
        status = getline line <bytecodeFile;
        if (status == 0) break;
        if (status < 0) {
            print "trouble reading bytecode file";
            exit 1;
        }

        # Clean up the line and extract the command.
        gsub(/  */, " ", line);
        sub(/ *#.*$/, "", line);
        sub(/ $/, "", line);
        sub(/^ /, "", line);
        count = split(line, parts);
        if (count == 0) continue; # Blank or comment line.
        cmd = parts[1];
        sub(/^[a-z][a-z]* */, "", line); # Remove the command from line.

        if (cmd == "op") {
            status = defineOpcode(line);
        } else if (cmd == "format") {
            status = defineFormat(line);
        } else {
            status = -1;
        }

        if (status != 0) {
            printf("syntax error on line: %s\n", line);
        }
    }
}

# Define an opcode.
function defineOpcode(line, count, parts, idx) {
    # locals: count, parts, idx
    count = split(line, parts);
    if (count != 4)  return -1;
    idx = parseHex(parts[1]);
    if (idx < 0) return -1;

    hex[idx] = parts[1];
    format[idx] = parts[2];
    hasres[idx] = (parts[3] == "n") ? "false" : "true";
    name[idx] = parts[4];
    uppername[idx] = toupper(parts[4]);
    gsub("[---/]", "_", uppername[idx]);
    split(name[idx], parts, "/");
    family[idx] = toupper(parts[1]);
    gsub("-", "_", family[idx]);

    # This association is used when computing "next" opcodes.
    familyFormat[family[idx],format[idx]] = idx;

    if (nextFormat[format[idx]] == "") {
        printf("unknown format: %s\n", format[idx]);
        return 1;
    }

    return 0;
}

# Define a format family.
function defineFormat(line, count, parts, i) {
    # locals: count, parts, i
    count = split(line, parts);
    if (count < 1)  return -1;
    formats[parts[1]] = line;

    parts[count + 1] = "none";
    for (i = 1; i <= count; i++) {
        nextFormat[parts[i]] = parts[i + 1];
    }

    return 0;
}

# Produce the nextOpcode and isFirst arrays. The former indicates, for
# each opcode, which one should be tried next when doing instruction
# fitting. The latter indicates which opcodes are at the head of an
# instruction fitting chain.
function deriveOpcodeChains(i, op) {
    # locals: i, op

    for (i = 0; i <= MAX_OPCODE; i++) {
        if ((hex[i] == "") || (index(name[i], "unused") != 0)) {
            continue;
        }
        isFirst[i] = "true";
    }

    for (i = 0; i <= MAX_OPCODE; i++) {
        if ((hex[i] == "") || (index(name[i], "unused") != 0)) {
            continue;
        }
        op = findNextOpcode(i);
        nextOpcode[i] = op;
        if (op != -1) {
            isFirst[op] = "false";
        }
    }
}

# Given an opcode by index, find the next opcode in the same family
# (that is, with the same base name) to try when matching instructions
# to opcodes. This simply walks the nextFormat chain looking for a
# match. This returns the index of the matching opcode or -1 if there
# is none.
function findNextOpcode(idx, fam, fmt, result) {
    # locals: fam, fmt, result
    fam = family[idx];
    fmt = format[idx];

    # Not every opcode has a version with every possible format, so
    # we have to iterate down the chain until we find one or run out of
    # formats to try.
    for (fmt = nextFormat[format[idx]]; fmt != "none"; fmt = nextFormat[fmt]) {
        result = familyFormat[fam,fmt];
        if (result != "") {
            return result;
        }
    }

    return -1;
}

# Convert a hex value to an int.
function parseHex(hex, result, chars, count, c, i) {
    # locals: result, chars, count, c, i
    hex = tolower(hex);
    count = split(hex, chars, "");
    result = 0;
    for (i = 1; i <= count; i++) {
        c = index("0123456789abcdef", chars[i]);
        if (c == 0) {
            printf("bogus hex value: %s\n", hex);
            return -1;
        }
        result = (result * 16) + c - 1;
    }
    return result;
}
' "$file" > "$tmpfile"

cp "$tmpfile" "$file"
rm "$tmpfile"
